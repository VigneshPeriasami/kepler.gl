"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.addDataToMapComposed = exports.updateVisDataComposed = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _actionTypes = _interopRequireDefault(require("../constants/action-types"));

var _mapStateUpdaters = require("./map-state-updaters");

var _uiStateUpdaters = require("./ui-state-updaters");

var _visStateUpdaters = require("./vis-state-updaters");

var _mapStyleUpdaters = require("./map-style-updaters");

var _dataUtils = require("../utils/data-utils");

var _schemas = _interopRequireDefault(require("../schemas"));

var _compostedUpdaters;

// compose action to apply result multiple reducers, with the output of one

/**
 * Apply data and config to visState reducer
 * @param {object} state
 * @param {object} action
 * @param {object} action.options
 * @param {Boolean} action.options.centerMap
 * @param {Boolean} action.options.readOnly
 * @param {object} action.config
 * @returns state new reducer state
 */
var updateVisDataComposed = function updateVisDataComposed(state, action) {
  // keep a copy of oldLayers
  var oldLayers = state.visState.layers;
  var visState = (0, _visStateUpdaters.updateVisDataUpdater)(state.visState, action);
  var defaultOptions = {
    centerMap: true
  };
  var options = (0, _objectSpread2.default)({}, defaultOptions, action.options);
  var bounds;

  if (options.centerMap) {
    // find map bounds for new layers
    var newLayers = visState.layers.filter(function (nl) {
      return !oldLayers.find(function (ol) {
        return ol === nl;
      });
    });
    bounds = (0, _dataUtils.findMapBounds)(newLayers);
  }

  return (0, _objectSpread2.default)({}, state, {
    visState: visState,
    mapState: bounds ? (0, _mapStateUpdaters.fitBoundsUpdater)(state.mapState, {
      payload: bounds
    }) : state.mapState,
    uiState: (0, _objectSpread2.default)({}, (0, _uiStateUpdaters.toggleModalUpdater)(state.uiState, {
      payload: null
    }), options.hasOwnProperty('readOnly') ? {
      readOnly: options.readOnly
    } : {})
  });
};
/**
 * Combine data and full configuration update in a single action
 * @param state
 * @param action {datasets, options, config}
 * @returns state
 */


exports.updateVisDataComposed = updateVisDataComposed;

var addDataToMapComposed = function addDataToMapComposed(state, action) {
  var _action$payload = action.payload,
      datasets = _action$payload.datasets,
      options = _action$payload.options,
      config = _action$payload.config;
  var parsedConfig = config;

  if (config && config.config && config.version) {
    // if passed in saved config
    parsedConfig = _schemas.default.parseSavedConfig(config);
  } // Update visState store


  var mergedState = updateVisDataComposed(state, {
    datasets: datasets,
    options: options,
    config: parsedConfig && parsedConfig.visState
  }); // Update mapState store

  mergedState = (0, _objectSpread2.default)({}, mergedState, {
    mapState: (0, _mapStateUpdaters.receiveMapConfigUpdater)(mergedState.mapState, {
      payload: {
        mapState: parsedConfig && parsedConfig.mapState
      }
    })
  }); // Update mapStyle store

  mergedState = (0, _objectSpread2.default)({}, mergedState, {
    mapStyle: (0, _mapStyleUpdaters.receiveMapConfigUpdater)(mergedState.mapStyle, {
      payload: {
        mapStyle: parsedConfig && parsedConfig.mapStyle
      }
    })
  });
  return mergedState;
};

exports.addDataToMapComposed = addDataToMapComposed;
var compostedUpdaters = (_compostedUpdaters = {}, (0, _defineProperty2.default)(_compostedUpdaters, _actionTypes.default.UPDATE_VIS_DATA, updateVisDataComposed), (0, _defineProperty2.default)(_compostedUpdaters, _actionTypes.default.ADD_DATA_TO_MAP, addDataToMapComposed), _compostedUpdaters);
var _default = compostedUpdaters;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9jb21wb3NlcnMuanMiXSwibmFtZXMiOlsidXBkYXRlVmlzRGF0YUNvbXBvc2VkIiwic3RhdGUiLCJhY3Rpb24iLCJvbGRMYXllcnMiLCJ2aXNTdGF0ZSIsImxheWVycyIsImRlZmF1bHRPcHRpb25zIiwiY2VudGVyTWFwIiwib3B0aW9ucyIsImJvdW5kcyIsIm5ld0xheWVycyIsImZpbHRlciIsIm5sIiwiZmluZCIsIm9sIiwibWFwU3RhdGUiLCJwYXlsb2FkIiwidWlTdGF0ZSIsImhhc093blByb3BlcnR5IiwicmVhZE9ubHkiLCJhZGREYXRhVG9NYXBDb21wb3NlZCIsImRhdGFzZXRzIiwiY29uZmlnIiwicGFyc2VkQ29uZmlnIiwidmVyc2lvbiIsIktlcGxlckdsU2NoZW1hIiwicGFyc2VTYXZlZENvbmZpZyIsIm1lcmdlZFN0YXRlIiwibWFwU3R5bGUiLCJjb21wb3N0ZWRVcGRhdGVycyIsIkFjdGlvblR5cGVzIiwiVVBEQVRFX1ZJU19EQVRBIiwiQUREX0RBVEFfVE9fTUFQIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVTyxJQUFNQSxxQkFBcUIsR0FBRyxTQUF4QkEscUJBQXdCLENBQUNDLEtBQUQsRUFBUUMsTUFBUixFQUFtQjtBQUN0RDtBQUNBLE1BQU1DLFNBQVMsR0FBR0YsS0FBSyxDQUFDRyxRQUFOLENBQWVDLE1BQWpDO0FBRUEsTUFBTUQsUUFBUSxHQUFHLDRDQUFxQkgsS0FBSyxDQUFDRyxRQUEzQixFQUFxQ0YsTUFBckMsQ0FBakI7QUFFQSxNQUFNSSxjQUFjLEdBQUc7QUFDckJDLElBQUFBLFNBQVMsRUFBRTtBQURVLEdBQXZCO0FBSUEsTUFBTUMsT0FBTyxtQ0FDUkYsY0FEUSxFQUVSSixNQUFNLENBQUNNLE9BRkMsQ0FBYjtBQUtBLE1BQUlDLE1BQUo7O0FBQ0EsTUFBSUQsT0FBTyxDQUFDRCxTQUFaLEVBQXVCO0FBQ3JCO0FBQ0EsUUFBTUcsU0FBUyxHQUFHTixRQUFRLENBQUNDLE1BQVQsQ0FBZ0JNLE1BQWhCLENBQXVCLFVBQUFDLEVBQUU7QUFBQSxhQUFJLENBQUNULFNBQVMsQ0FBQ1UsSUFBVixDQUFlLFVBQUFDLEVBQUU7QUFBQSxlQUFJQSxFQUFFLEtBQUtGLEVBQVg7QUFBQSxPQUFqQixDQUFMO0FBQUEsS0FBekIsQ0FBbEI7QUFDQUgsSUFBQUEsTUFBTSxHQUFHLDhCQUFjQyxTQUFkLENBQVQ7QUFDRDs7QUFFRCx5Q0FDS1QsS0FETDtBQUVFRyxJQUFBQSxRQUFRLEVBQVJBLFFBRkY7QUFHRVcsSUFBQUEsUUFBUSxFQUFFTixNQUFNLEdBQ1osd0NBQWlCUixLQUFLLENBQUNjLFFBQXZCLEVBQWlDO0FBQy9CQyxNQUFBQSxPQUFPLEVBQUVQO0FBRHNCLEtBQWpDLENBRFksR0FJWlIsS0FBSyxDQUFDYyxRQVBaO0FBUUVFLElBQUFBLE9BQU8sa0NBQ0YseUNBQW1CaEIsS0FBSyxDQUFDZ0IsT0FBekIsRUFBa0M7QUFBQ0QsTUFBQUEsT0FBTyxFQUFFO0FBQVYsS0FBbEMsQ0FERSxFQUVEUixPQUFPLENBQUNVLGNBQVIsQ0FBdUIsVUFBdkIsSUFBcUM7QUFBQ0MsTUFBQUEsUUFBUSxFQUFFWCxPQUFPLENBQUNXO0FBQW5CLEtBQXJDLEdBQW9FLEVBRm5FO0FBUlQ7QUFhRCxDQW5DTTtBQXFDUDs7Ozs7Ozs7OztBQU1PLElBQU1DLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBQ25CLEtBQUQsRUFBUUMsTUFBUixFQUFtQjtBQUFBLHdCQUVqQkEsTUFBTSxDQUFDYyxPQUZVO0FBQUEsTUFFOUNLLFFBRjhDLG1CQUU5Q0EsUUFGOEM7QUFBQSxNQUVwQ2IsT0FGb0MsbUJBRXBDQSxPQUZvQztBQUFBLE1BRTNCYyxNQUYyQixtQkFFM0JBLE1BRjJCO0FBR3JELE1BQUlDLFlBQVksR0FBR0QsTUFBbkI7O0FBRUEsTUFBSUEsTUFBTSxJQUFJQSxNQUFNLENBQUNBLE1BQWpCLElBQTJCQSxNQUFNLENBQUNFLE9BQXRDLEVBQStDO0FBQzdDO0FBQ0FELElBQUFBLFlBQVksR0FBR0UsaUJBQWVDLGdCQUFmLENBQWdDSixNQUFoQyxDQUFmO0FBQ0QsR0FSb0QsQ0FTckQ7OztBQUNBLE1BQUlLLFdBQVcsR0FBRzNCLHFCQUFxQixDQUFDQyxLQUFELEVBQVE7QUFBQ29CLElBQUFBLFFBQVEsRUFBUkEsUUFBRDtBQUFXYixJQUFBQSxPQUFPLEVBQVBBLE9BQVg7QUFBb0JjLElBQUFBLE1BQU0sRUFBRUMsWUFBWSxJQUFJQSxZQUFZLENBQUNuQjtBQUF6RCxHQUFSLENBQXZDLENBVnFELENBWXJEOztBQUNBdUIsRUFBQUEsV0FBVyxtQ0FDTkEsV0FETTtBQUVUWixJQUFBQSxRQUFRLEVBQUUsK0NBQXNCWSxXQUFXLENBQUNaLFFBQWxDLEVBQTRDO0FBQUNDLE1BQUFBLE9BQU8sRUFBRTtBQUFDRCxRQUFBQSxRQUFRLEVBQUVRLFlBQVksSUFBSUEsWUFBWSxDQUFDUjtBQUF4QztBQUFWLEtBQTVDO0FBRkQsSUFBWCxDQWJxRCxDQWtCckQ7O0FBQ0FZLEVBQUFBLFdBQVcsbUNBQ05BLFdBRE07QUFFVEMsSUFBQUEsUUFBUSxFQUFFLCtDQUFzQkQsV0FBVyxDQUFDQyxRQUFsQyxFQUE0QztBQUFDWixNQUFBQSxPQUFPLEVBQUU7QUFBQ1ksUUFBQUEsUUFBUSxFQUFFTCxZQUFZLElBQUlBLFlBQVksQ0FBQ0s7QUFBeEM7QUFBVixLQUE1QztBQUZELElBQVg7QUFLQSxTQUFPRCxXQUFQO0FBQ0QsQ0F6Qk07OztBQTJCUCxJQUFNRSxpQkFBaUIsK0VBQ3BCQyxxQkFBWUMsZUFEUSxFQUNVL0IscUJBRFYscURBRXBCOEIscUJBQVlFLGVBRlEsRUFFVVosb0JBRlYsc0JBQXZCO2VBS2VTLGlCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE5IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IEFjdGlvblR5cGVzIGZyb20gJ2NvbnN0YW50cy9hY3Rpb24tdHlwZXMnO1xuaW1wb3J0IHtmaXRCb3VuZHNVcGRhdGVyfSBmcm9tICcuL21hcC1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge3RvZ2dsZU1vZGFsVXBkYXRlcn0gZnJvbSAnLi91aS1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge3VwZGF0ZVZpc0RhdGFVcGRhdGVyfSBmcm9tICcuL3Zpcy1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge3JlY2VpdmVNYXBDb25maWdVcGRhdGVyIGFzIHN0YXRlTWFwQ29uZmlnVXBkYXRlcn0gZnJvbSAnLi9tYXAtc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciBhcyBzdHlsZU1hcENvbmZpZ1VwZGF0ZXJ9IGZyb20gJy4vbWFwLXN0eWxlLXVwZGF0ZXJzJztcbmltcG9ydCB7ZmluZE1hcEJvdW5kc30gZnJvbSAndXRpbHMvZGF0YS11dGlscyc7XG5pbXBvcnQgS2VwbGVyR2xTY2hlbWEgZnJvbSAnc2NoZW1hcyc7XG5cbi8vIGNvbXBvc2UgYWN0aW9uIHRvIGFwcGx5IHJlc3VsdCBtdWx0aXBsZSByZWR1Y2Vycywgd2l0aCB0aGUgb3V0cHV0IG9mIG9uZVxuXG4vKipcbiAqIEFwcGx5IGRhdGEgYW5kIGNvbmZpZyB0byB2aXNTdGF0ZSByZWR1Y2VyXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhY3Rpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBhY3Rpb24ub3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBhY3Rpb24ub3B0aW9ucy5jZW50ZXJNYXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWN0aW9uLm9wdGlvbnMucmVhZE9ubHlcbiAqIEBwYXJhbSB7b2JqZWN0fSBhY3Rpb24uY29uZmlnXG4gKiBAcmV0dXJucyBzdGF0ZSBuZXcgcmVkdWNlciBzdGF0ZVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlVmlzRGF0YUNvbXBvc2VkID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgLy8ga2VlcCBhIGNvcHkgb2Ygb2xkTGF5ZXJzXG4gIGNvbnN0IG9sZExheWVycyA9IHN0YXRlLnZpc1N0YXRlLmxheWVycztcblxuICBjb25zdCB2aXNTdGF0ZSA9IHVwZGF0ZVZpc0RhdGFVcGRhdGVyKHN0YXRlLnZpc1N0YXRlLCBhY3Rpb24pO1xuXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGNlbnRlck1hcDogdHJ1ZVxuICB9O1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4uYWN0aW9uLm9wdGlvbnNcbiAgfTtcblxuICBsZXQgYm91bmRzO1xuICBpZiAob3B0aW9ucy5jZW50ZXJNYXApIHtcbiAgICAvLyBmaW5kIG1hcCBib3VuZHMgZm9yIG5ldyBsYXllcnNcbiAgICBjb25zdCBuZXdMYXllcnMgPSB2aXNTdGF0ZS5sYXllcnMuZmlsdGVyKG5sID0+ICFvbGRMYXllcnMuZmluZChvbCA9PiBvbCA9PT0gbmwpKTtcbiAgICBib3VuZHMgPSBmaW5kTWFwQm91bmRzKG5ld0xheWVycyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHZpc1N0YXRlLFxuICAgIG1hcFN0YXRlOiBib3VuZHNcbiAgICAgID8gZml0Qm91bmRzVXBkYXRlcihzdGF0ZS5tYXBTdGF0ZSwge1xuICAgICAgICAgIHBheWxvYWQ6IGJvdW5kc1xuICAgICAgICB9KVxuICAgICAgOiBzdGF0ZS5tYXBTdGF0ZSxcbiAgICB1aVN0YXRlOiB7XG4gICAgICAuLi50b2dnbGVNb2RhbFVwZGF0ZXIoc3RhdGUudWlTdGF0ZSwge3BheWxvYWQ6IG51bGx9KSxcbiAgICAgIC4uLihvcHRpb25zLmhhc093blByb3BlcnR5KCdyZWFkT25seScpID8ge3JlYWRPbmx5OiBvcHRpb25zLnJlYWRPbmx5fSA6IHt9KVxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQ29tYmluZSBkYXRhIGFuZCBmdWxsIGNvbmZpZ3VyYXRpb24gdXBkYXRlIGluIGEgc2luZ2xlIGFjdGlvblxuICogQHBhcmFtIHN0YXRlXG4gKiBAcGFyYW0gYWN0aW9uIHtkYXRhc2V0cywgb3B0aW9ucywgY29uZmlnfVxuICogQHJldHVybnMgc3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZERhdGFUb01hcENvbXBvc2VkID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcblxuICBjb25zdCB7ZGF0YXNldHMsIG9wdGlvbnMsIGNvbmZpZ30gPSBhY3Rpb24ucGF5bG9hZDtcbiAgbGV0IHBhcnNlZENvbmZpZyA9IGNvbmZpZztcblxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb25maWcgJiYgY29uZmlnLnZlcnNpb24pIHtcbiAgICAvLyBpZiBwYXNzZWQgaW4gc2F2ZWQgY29uZmlnXG4gICAgcGFyc2VkQ29uZmlnID0gS2VwbGVyR2xTY2hlbWEucGFyc2VTYXZlZENvbmZpZyhjb25maWcpXG4gIH1cbiAgLy8gVXBkYXRlIHZpc1N0YXRlIHN0b3JlXG4gIGxldCBtZXJnZWRTdGF0ZSA9IHVwZGF0ZVZpc0RhdGFDb21wb3NlZChzdGF0ZSwge2RhdGFzZXRzLCBvcHRpb25zLCBjb25maWc6IHBhcnNlZENvbmZpZyAmJiBwYXJzZWRDb25maWcudmlzU3RhdGV9KTtcblxuICAvLyBVcGRhdGUgbWFwU3RhdGUgc3RvcmVcbiAgbWVyZ2VkU3RhdGUgPSB7XG4gICAgLi4ubWVyZ2VkU3RhdGUsXG4gICAgbWFwU3RhdGU6IHN0YXRlTWFwQ29uZmlnVXBkYXRlcihtZXJnZWRTdGF0ZS5tYXBTdGF0ZSwge3BheWxvYWQ6IHttYXBTdGF0ZTogcGFyc2VkQ29uZmlnICYmIHBhcnNlZENvbmZpZy5tYXBTdGF0ZX19KVxuICB9O1xuXG4gIC8vIFVwZGF0ZSBtYXBTdHlsZSBzdG9yZVxuICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAuLi5tZXJnZWRTdGF0ZSxcbiAgICBtYXBTdHlsZTogc3R5bGVNYXBDb25maWdVcGRhdGVyKG1lcmdlZFN0YXRlLm1hcFN0eWxlLCB7cGF5bG9hZDoge21hcFN0eWxlOiBwYXJzZWRDb25maWcgJiYgcGFyc2VkQ29uZmlnLm1hcFN0eWxlfX0pXG4gIH07XG5cbiAgcmV0dXJuIG1lcmdlZFN0YXRlXG59O1xuXG5jb25zdCBjb21wb3N0ZWRVcGRhdGVycyA9IHtcbiAgW0FjdGlvblR5cGVzLlVQREFURV9WSVNfREFUQV06IHVwZGF0ZVZpc0RhdGFDb21wb3NlZCxcbiAgW0FjdGlvblR5cGVzLkFERF9EQVRBX1RPX01BUF06IGFkZERhdGFUb01hcENvbXBvc2VkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb21wb3N0ZWRVcGRhdGVycztcbiJdfQ==